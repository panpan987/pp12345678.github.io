<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java面试题（收集于视频、博客、野史、民间传说） | 不错的网站</title><meta name="author" content="panda17"><meta name="copyright" content="panda17"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、面向对象对比面向过程，是两种不同的处理问题的角度 面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者、及各自需要做什么 面向对象三大特征： 封装：内部细节对外部调用透明，外部调用无需修改或关心内部实现 继承：子类共性的方法或属性直接使用父类，而不需要自己再定义，只需扩展自己个性化。 多态：基于对象所属类的不同，外部对同一方法的调用，实际执行的逻辑不同。 2、JDK、JRE、J">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题（收集于视频、博客、野史、民间传说）">
<meta property="og:url" content="http://pp12345678.github.io/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/index.html">
<meta property="og:site_name" content="不错的网站">
<meta property="og:description" content="1、面向对象对比面向过程，是两种不同的处理问题的角度 面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者、及各自需要做什么 面向对象三大特征： 封装：内部细节对外部调用透明，外部调用无需修改或关心内部实现 继承：子类共性的方法或属性直接使用父类，而不需要自己再定义，只需扩展自己个性化。 多态：基于对象所属类的不同，外部对同一方法的调用，实际执行的逻辑不同。 2、JDK、JRE、J">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-04-16T07:21:12.000Z">
<meta property="article:modified_time" content="2021-07-18T06:50:02.443Z">
<meta property="article:author" content="panda17">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://pp12345678.github.io/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-18 14:50:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/null" onerror="onerror=null;src='/img/lm.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-flag-checkered"></i><span> 集合</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw far fa-laugh-beam"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page" href="/sound/"><i class="fa-fw fas fa-headphones-alt"></i><span> 中文音声</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/relaxation/"><i class="fa-fw fas fa-gamepad"></i><span> 小游戏</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">不错的网站</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-flag-checkered"></i><span> 集合</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw far fa-laugh-beam"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page" href="/sound/"><i class="fa-fw fas fa-headphones-alt"></i><span> 中文音声</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/relaxation/"><i class="fa-fw fas fa-gamepad"></i><span> 小游戏</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java面试题（收集于视频、博客、野史、民间传说）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-16T07:21:12.000Z" title="发表于 2021-04-16 15:21:12">2021-04-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-18T06:50:02.443Z" title="更新于 2021-07-18 14:50:02">2021-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1、面向对象"><a href="#1、面向对象" class="headerlink" title="1、面向对象"></a>1、面向对象</h1><p>对比面向过程，是两种不同的处理问题的角度</p>
<p>面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者、及各自需要做什么</p>
<p>面向对象三大特征：</p>
<p><strong>封装</strong>：内部细节对外部调用透明，外部调用无需修改或关心内部实现</p>
<p><strong>继承</strong>：子类共性的方法或属性直接使用父类，而不需要自己再定义，只需扩展自己个性化。</p>
<p><strong>多态</strong>：基于对象所属类的不同，外部对同一方法的调用，实际执行的逻辑不同。</p>
<h1 id="2、JDK、JRE、JVM三者区别和联系"><a href="#2、JDK、JRE、JVM三者区别和联系" class="headerlink" title="2、JDK、JRE、JVM三者区别和联系"></a>2、JDK、JRE、JVM三者区别和联系</h1><p>JDK是Java Development Kit，即Java开发工具，是给使用Java开发程序的人使用的</p>
<p>JRE是Java Runtime Environment , 即Java运行时环境</p>
<p>JVM是Java Virtual Machine，即Java虚拟机</p>
<p><img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210416173438596.png" alt="image-20210416173438596"></p>
<h1 id="3、-和equals"><a href="#3、-和equals" class="headerlink" title="3、==和equals"></a>3、==和equals</h1><p>==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址</p>
<p>equals: Object中默认也是采用==比较，通常会重写(如String类的equals比较内容，还有包装类也重写了equals，如Double、Integer)</p>
<p>Object</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-final"><a href="#4-final" class="headerlink" title="4.final"></a>4.final</h1><ul>
<li>修饰类：类不能被继承</li>
<li>修饰方法：方法不可以被子类覆盖，但可以重载</li>
<li>修饰变量：变量一旦被赋值就不可以更改它的值</li>
</ul>
<p>局部内部内和匿名内部类只能访问局部final变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.springboot.panda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outPrint</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InClass</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> InClass().InPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，内部类和外部类都处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。当外部类的方法结束时，局部变量就会被销毁，但内部类对象可能还存在，这里就会出现一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是外部类局部变量的拷贝。</p>
<h1 id="5-String、StringBuffer、StringBuilder区别及使用场景"><a href="#5-String、StringBuffer、StringBuilder区别及使用场景" class="headerlink" title="5.String、StringBuffer、StringBuilder区别及使用场景"></a>5.String、StringBuffer、StringBuilder区别及使用场景</h1><p>String是final修饰的，不可变，每次操作都是产生新的String对象</p>
<p>StringBuffer和StringBuilder都是在原对象上操作</p>
<p>StringBuffer是线程安全的，StringBuilder线程不安全的</p>
<p>StringBuffer方法都是synchronized修饰的</p>
<p>性能：StringBuilder&gt;StringBuffer&gt;String</p>
<p>场景：经常需要改变字符串内容时使用StringBuffer、StringBuilder</p>
<p>优先使用StringBuilder，多线程使用共享变量时使用StringBuffer</p>
<h1 id="6-重载和重写的区别"><a href="#6-重载和重写的区别" class="headerlink" title="6.重载和重写的区别"></a>6.重载和重写的区别</h1><p><strong>重载</strong>：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法的返回值和访问修饰符可以不同，发生在编译时。</p>
<p><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常返回小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p>
<h1 id="7-接口和抽象类的区别"><a href="#7-接口和抽象类的区别" class="headerlink" title="7. 接口和抽象类的区别"></a>7. 接口和抽象类的区别</h1><ul>
<li>抽象类可以存在普通成员函数，而接口中只能存在public abstract方法。</li>
<li>抽象类中的成员变量可以是各种类型，而接口中的成员变量只能是public static final类型的。</li>
<li>抽象类只能继承一个，接口可以实现多个。 </li>
</ul>
<p>接口的设计，为了对类的行为约束，相当于定义规范</p>
<p>抽象类的设计，为了代码复用，当不同的类具有某些相同的行为，可以让这些类都派生于一个抽象类。抽象类中可以有具体方法，也可以有抽象方法，不能实例化</p>
<h1 id="8-list和set的区别"><a href="#8-list和set的区别" class="headerlink" title="8.list和set的区别"></a>8.list和set的区别</h1><p><strong>list</strong>：有序，按对象进入的顺序保存对象，可重复，允许多个null元素对象，可以使用iterator取出所有元素，再逐一遍历，还可以使用get（int index）获取指定下标的元素。</p>
<p><strong>set</strong>：无序，不可重复，最多允许有一个null元素对象，取元素只能用iterator接口取得所有元素，再逐一遍历各个元素。</p>
<h1 id="9-hashCode和equals"><a href="#9-hashCode和equals" class="headerlink" title="9.hashCode和equals"></a>9.hashCode和equals</h1><p>hashCode()作用是获取哈希码，也称散列码；它实际返回int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。散列表存储的是键值对（key-value），它的特点：能根据“键”快速地检索出对应的“值”，可以快速在堆中找到对象。</p>
<p>为什么要有hashCode？</p>
<p>以hashSet如何检查重复为例子来说明为什么要有hashCode：</p>
<p>对象加入HashSet时，hashSet会先计算对象的hashCode值来判断对象加入的位置，看该位置是否有值，如果没有，HashSet会假设对象没有重复出现，如果有值，这时会调用equals（）方法来检查两个对象是否真的相同。如果两者相同，hashset就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样大大减少了equals的次数。相当就大大提高执行速度。  </p>
<ul>
<li>如果两个对象相等，则hashCode一定也是相同的</li>
<li>两个对象相等，对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同hashCode值，它们也不一定是相等的</li>
<li>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode（）的默认行为是对堆上的对象产生独特值，如果没有重写hashCode（），则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
<h1 id="10-ArrayList和LinkedList区别"><a href="#10-ArrayList和LinkedList区别" class="headerlink" title="10.ArrayList和LinkedList区别"></a>10.ArrayList和LinkedList区别</h1><p>ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动，使用尾插法并指定初始容量可以极大提升性能，甚至超过LinkedList（需要创建大量的node对象）。</p>
<p>LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询；需要逐一遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get（i）取得某一元素时都需要对list重新进行遍历，性能消耗极大。创建对象node消耗性能</p>
<h1 id="11-HashMap和HashTable的区别？底层实现是什么？"><a href="#11-HashMap和HashTable的区别？底层实现是什么？" class="headerlink" title="11. HashMap和HashTable的区别？底层实现是什么？"></a>11. HashMap和HashTable的区别？底层实现是什么？</h1><p>1.区别：</p>
<p>​    （1）HashMap线程非安全，HashTable方法使用synchronized修饰，线程安全；</p>
<p>​    （2）HashMap允许key和value为null，而HashTable不允许；</p>
<p>2.底层实现：数组+链表实现</p>
<p>jdk8开始在链表高度到8，数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在</p>
<ul>
<li>计算key的hash值，二次hash然后对数组长度取模，对应到数组下标</li>
<li>如果没有产生hash冲突（下标位置没有元素），则直接创建Node存入数组</li>
<li>如果产生hash冲突，先进行equals比较，相同则取代该元素，不同，则判断链表高度插入链表， 链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转为链表</li>
<li>key为null，存在下标0的位置</li>
</ul>
<p>数组扩容</p>
<h1 id="12-ConcurrentHashMap原理，jdk7和jdk8版本的区别"><a href="#12-ConcurrentHashMap原理，jdk7和jdk8版本的区别" class="headerlink" title="12.ConcurrentHashMap原理，jdk7和jdk8版本的区别"></a>12.ConcurrentHashMap原理，jdk7和jdk8版本的区别</h1><p>jdk7：</p>
<p>数据结构：ReentrantLock+Segment+HashEntry</p>
<p>jdk8: </p>
<p>数据结构：synchronized+CAS+Node+红黑树</p>
<h1 id="13-如何实现一个IOC容器"><a href="#13-如何实现一个IOC容器" class="headerlink" title="13.如何实现一个IOC容器"></a>13.如何实现一个IOC容器</h1><p>1.配置文件配置包扫描路径</p>
<p>2.递归包扫描获取.class文件</p>
<p>3.反射、确定需要交给IOC管理的类</p>
<p>4.对需要注入的类进行依赖注入</p>
<h1 id="14-什么是字节码？采用字节码的好处是什么？"><a href="#14-什么是字节码？采用字节码的好处是什么？" class="headerlink" title="14.什么是字节码？采用字节码的好处是什么？"></a>14.什么是字节码？采用字节码的好处是什么？</h1><p>jvm能理解的代码叫字节码（.class文件）</p>
<p>java源程序经过编译器编译成字节码，字节码有虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这也就是解释了Java的编译与解释并存的特点。</p>
<h1 id="15-Java类加载器有哪些"><a href="#15-Java类加载器有哪些" class="headerlink" title="15.Java类加载器有哪些"></a>15.Java类加载器有哪些</h1><p>JDk自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader.</p>
<p>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件。</p>
<p>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和class类。</p>
<p>AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。系统类加载器、线程上下文加载器</p>
<p>自定义类加载器</p>
<h1 id="16-双亲委派模型"><a href="#16-双亲委派模型" class="headerlink" title="16. 双亲委派模型"></a>16. 双亲委派模型</h1><p><img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210417190414649.png" alt="image-20210417190414649"></p>
<p>当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。<br>————————————————<br>版权声明：本文为CSDN博主「IT烂笔头」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/codeyanbao/article/details/82875064">https://blog.csdn.net/codeyanbao/article/details/82875064</a></p>
<p>双亲委派模型的好处：</p>
<ul>
<li>主要是为了安全性，避免用户自己编写的类动态替换Java的一些核心类，比如String。</li>
<li>同时也避免了类的重复加载，因为jvm中区别不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类</li>
</ul>
<h1 id="17-Java中的异常体系"><a href="#17-Java中的异常体系" class="headerlink" title="17.Java中的异常体系"></a>17.Java中的异常体系</h1><p>Java中的所有异常都来自顶级父类Throwable</p>
<p>Throwable下有两个子类Exception和Error</p>
<p>Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。（OOM）</p>
<p>Exception不会导致程序停止，又分为两个部分RuntimeException运行时异常和CheckedException检查异常。 RuntimeException常常发生在程序运行过程中，会导致程序当前线程执行失败，CheckedException常常发生在程序编译过程中，会导致程序编译不通过。</p>
<h1 id="18-GC如何判断对象可以被回收"><a href="#18-GC如何判断对象可以被回收" class="headerlink" title="18.GC如何判断对象可以被回收"></a>18.GC如何判断对象可以被回收</h1><ul>
<li>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收</li>
<li>可达性分析法（Java采用）：从GC Roots开始向下搜索， 搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</li>
</ul>
<blockquote>
<p>引用计数法，可能会出现A引用了B，B又引用了A，这时候就算他们都不再使用了，但因为相互引用计数器=1 永远无法被回收</p>
</blockquote>
<p>GC Roots的对象有：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈JNI（即一般说得Native方法）引用的对象</li>
</ul>
<h1 id="19-线程的生命周期，线程有哪些状态"><a href="#19-线程的生命周期，线程有哪些状态" class="headerlink" title="19.线程的生命周期，线程有哪些状态"></a>19.线程的生命周期，线程有哪些状态</h1><ol>
<li><p>线程通常有5种状态，创建，就绪，运行，阻塞，死亡</p>
</li>
<li><p>阻塞的情况又分为3种</p>
<ul>
<li>等待阻塞：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中，进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤醒，wait是object类的方法</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</li>
<li>其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。sleep是Thread类的方法。</li>
</ul>
</li>
<li><blockquote>
<ol>
<li>新建状态（New）：新创建了一个线程对象。</li>
<li>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li>
<li>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</li>
<li>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂停运行。直到线程进入就绪状态，才有机会转到运行状态。</li>
<li>死亡状态（Dead）：线程执行完了或者因为异常退出了run方法，该线程结束生命周期。</li>
</ol>
</blockquote>
</li>
</ol>
<h1 id="20-sleep（），wait（），join（），yield（）的区别"><a href="#20-sleep（），wait（），join（），yield（）的区别" class="headerlink" title="20.sleep（），wait（），join（），yield（）的区别"></a>20.sleep（），wait（），join（），yield（）的区别</h1><ol>
<li><p>锁池</p>
<p> 所有需要竞争同步锁的线程都会放在锁池中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配。</p>
</li>
<li><p>等待池</p>
<p> 当我们调用wait（）方法后，线程会放到等待池中，等待池的线程不会竞争同步锁。只有调用了notify（）或notifyAll（）后等待池的线程才会开始竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll（）是将等待池的所有线程放到锁池中</p>
</li>
<li><p>sleep是Thread类的静态本地方法，wait则是Object类的本地方法。</p>
</li>
<li><p>sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。</p>
<blockquote>
<p>sleep就是把cpu的执行资格和执行权限释放出去，不再允许此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而sleep时该线程有锁，那么slppe不会释放锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到锁，也就是说无法执行程序。</p>
</blockquote>
</li>
<li><p>sleep方法不依赖于同步器synchronized,但是wait需要依赖synchronized</p>
</li>
<li><p>sleep不需要被唤醒（休眠之后退出阻塞），但是wait需要</p>
</li>
<li><p>sleep一般用于当前线程休眠，或者轮询暂停操作，wait则多用于多线程之间的通信。</p>
</li>
<li><p>sleep会让出CPU执行时间且强制上下文切换，但wait则不一定，wait后可能还是有机会重新竞争到锁继续执行的。</p>
</li>
</ol>
<p>yield（）执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行</p>
<p>join（）执行后线程进入阻塞状态，例如在线程B中调用线程A的join，那么线程B会进入阻塞队列，直到线程A结束或中断线程。</p>
<h1 id="21-说说你对线程安全的理解"><a href="#21-说说你对线程安全的理解" class="headerlink" title="21.说说你对线程安全的理解"></a>21.说说你对线程安全的理解</h1><p>不是线程安全，应该是内存安全，堆是共享内存，可以被所有线程访问</p>
<blockquote>
<p>当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象时线程安全的。</p>
</blockquote>
<p><strong>堆</strong>是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以像系统要额外的堆，但是用完了要还给操作系统，要不然就是内存泄漏。</p>
<p><strong>栈</strong>是每个线程独有的，保存其运行状态和局部变量的。栈在线程开始的时候初始化，每个线程的栈相互独立。因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级程序语言里面显示的分配和释放。</p>
<p>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。</p>
<p>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。</p>
<h1 id="22-Thread、Runable的区别"><a href="#22-Thread、Runable的区别" class="headerlink" title="22.Thread、Runable的区别"></a>22.Thread、Runable的区别</h1><p>Thread是类， 实现了Runable接口，其他就是使用的区别。</p>
<h1 id="23-说说你对守护线程（后台线程，对比用户线程）的理解"><a href="#23-说说你对守护线程（后台线程，对比用户线程）的理解" class="headerlink" title="23.说说你对守护线程（后台线程，对比用户线程）的理解"></a>23.说说你对守护线程（后台线程，对比用户线程）的理解</h1><p>守护线程：为所有非守护线程提供服务的线程，任何一个守护线程都是整个JVM中所有非守护线程的保姆；</p>
<p>守护线程的作用是什么？</p>
<p>举例：GC垃圾回收线程。当我们的程序中不再有任何运行的Thread，程序就不会再产生垃圾，垃圾回收器就无事可做，所以当垃圾回收器是JVM上仅剩的线程时，垃圾回收线程会自动离开。</p>
<p>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</p>
<h1 id="24-ThreadLocal的原理和使用场景"><a href="#24-ThreadLocal的原理和使用场景" class="headerlink" title="24.ThreadLocal的原理和使用场景"></a>24.ThreadLocal的原理和使用场景</h1><p>ThreadLocalMap容器属于当前的线程，由一个个Entry对象构成</p>
<p>Entry由ThreadLocal和Object构成</p>
<p>当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，将值存储进ThreadLocalMap对象中。</p>
<p>当执行get方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，获取对应的value。</p>
<p>使用场景：</p>
<ol>
<li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li>
<li>线程间数据隔离。</li>
<li>进行事务操作，用于存储线程事务信息。</li>
<li>数据库连接，Session回话管理。</li>
</ol>
<h1 id="25-ThreadLocal内存泄漏的原因，如何避免"><a href="#25-ThreadLocal内存泄漏的原因，如何避免" class="headerlink" title="25. ThreadLocal内存泄漏的原因，如何避免"></a>25. ThreadLocal内存泄漏的原因，如何避免</h1><p><strong>内存泄漏</strong>：不再会被使用的对象或者变量占用的内存不能被回收</p>
<p><strong>OOM</strong>：内存不够用</p>
<p>内存泄漏会导致OOM</p>
<p><strong>强引用</strong>：使用最普遍的引用（new），一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足时，Java虚拟机宁愿抛出OOM，时程序异常终止，也不会回收对象。</p>
<p>如果想取消强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样JVM在合适的时间就会回收该对象。</p>
<p><strong>弱引用</strong>：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象，在Java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</p>
<p>ThreadLocal正确的使用：</p>
<ul>
<li>每次使用完ThreaLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的弱引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进行清除掉。</li>
</ul>
<h1 id="26-并发、并行、串行"><a href="#26-并发、并行、串行" class="headerlink" title="26.并发、并行、串行"></a>26.并发、并行、串行</h1><p>串行在时间上不可能发生重叠，前一个任务没有搞完，下一个任务就只能等着</p>
<p>并行在时间上是重叠的，两个任务在同一时刻互不干扰地同时执行。（多核CPU）</p>
<p>并发运行两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行。</p>
<h1 id="27-并发的三大特性"><a href="#27-并发的三大特性" class="headerlink" title="27.并发的三大特性"></a>27.并发的三大特性</h1><ul>
<li><p>原子性(synchronized)</p>
<p>  指在一个操作cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要不都不执行。</p>
<p>  但是原子性不能保证线程安全，虽然前3步是原子操作，但第4步由操作系统决定</p>
<p>  <img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210417222719568.png" alt="image-20210417222719568"></p>
</li>
<li><p>可见性（volatile、synchronized、final）</p>
<p>  当多线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。</p>
<p>  AtomicInteger—–&gt;volatitle(可见性、有序性)+cas（原子性）</p>
</li>
<li><p>有序性(volatile、synchronized)</p>
<p>  虚拟机不一定按照我们写的代码顺序来执行，有可能发生指令重排</p>
</li>
</ul>
<h1 id="28-为什么用线程池？解释线程池参数？"><a href="#28-为什么用线程池？解释线程池参数？" class="headerlink" title="28.为什么用线程池？解释线程池参数？"></a>28.为什么用线程池？解释线程池参数？</h1><ol>
<li>降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。</li>
<li>提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。</li>
<li>提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。</li>
</ol>
<ul>
<li><p><code>corePoolSize</code>代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建后不会消除，而是一直常驻线程池</p>
</li>
<li><p><code>maxinumPoolSize</code>代表的是最大线程数，表示最大允许被创建的线程数。</p>
</li>
<li><p><code>keepAliveTime</code>表示超出超出核心线程数的线程在这些时间都空闲的话，会被消除</p>
</li>
<li><p><code>workQueue</code>用来存放待执行的任务，假设我们现在的核心线程都已经被使用，还有任务进来则全部放入队列，直到整个队列被放满但任务再进入则会创建新的线程</p>
</li>
<li><p><code>ThreadFactory</code>线程工厂，用来生产线程的</p>
</li>
<li><p><code>Handler</code>任务拒绝策略，1.当我们调用shutdown等方法关闭线程池后。这时候及时线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续向线程池提交任务就会遭到拒绝。2.当达到最大线程数，线程池已经没有能力继续处理新提交的任务时，这时也拒绝。</p>
<p>  拒绝策略:</p>
<p>  ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务.</p>
</li>
</ul>
<h1 id="29-简述线程池处理流程"><a href="#29-简述线程池处理流程" class="headerlink" title="29.简述线程池处理流程"></a>29.简述线程池处理流程</h1><p><img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210417230211337.png" alt="image-20210417230211337"></p>
<h1 id="30-线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？"><a href="#30-线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？" class="headerlink" title="30.线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？"></a>30.线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？</h1><ol>
<li><p>一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。</p>
<p> 阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。</p>
<p> 阻塞队列自带阻塞和唤醒的功能。</p>
</li>
<li><p>在创建新线程时，要获取全局锁，这个时候其他线程就都阻塞，影响效率。</p>
</li>
</ol>
<p><img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210417231507545.png" alt="image-20210417231507545"></p>
<p>​    这个例子告诉我们不得已才去做外包</p>
<h1 id="31-线程池中线程复用原理"><a href="#31-线程池中线程复用原理" class="headerlink" title="31.线程池中线程复用原理"></a>31.线程池中线程复用原理</h1><p>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱之前通过Thread创建线程时的一个线程必须对应一个任务的限制。</p>
<p>​    在线程池中，同一个线程可以从阻塞队列中不断获取新的任务来执行，其核心原理在于线程池对Thread进行了封装，并不是每次执行任务都会调用Thread.start（） 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个任务中不停检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的run方法，将run方法当成一个普通的方法执行，通过这种方式只使用固定的线程就将所有任务的run方法串联起来。</p>
<h1 id="32-Spring是什么"><a href="#32-Spring是什么" class="headerlink" title="32.Spring是什么"></a>32.Spring是什么</h1><p>轻量级的开源的J2EE框架。它是一个容器框架，用来封装JavaBean（java对象），中间层框架可以起一个连接作用，比如将struts和hibernate粘合在一起运用。</p>
<p>Spring是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架</p>
<ul>
<li>从大小与开销这两方面而言spring都是轻量级的。</li>
<li>通过IoC技术达到松耦合的目的。</li>
<li>提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发。</li>
<li>提供并管理应用对象（bean）的配置和生命周期，这个意义上是一个容器。</li>
<li>将简单的组件配置、组合成为复杂的应用，这个意义上是一个框架。</li>
</ul>
<h1 id="33-对AOP的理解"><a href="#33-对AOP的理解" class="headerlink" title="33.对AOP的理解"></a>33.对AOP的理解</h1><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能，除了实现自身核心功能，这些组件还承担额外职责</p>
<p>在OOP设计中，它导致大量代码重复，不利于各个模块的重用</p>
<p>AOP将程序中的交叉业务逻辑（安全，日志，事务），封装成一个切面，然后注入到目标对象中去，使用了动态代理实现</p>
<h1 id="34-对IOC的理解"><a href="#34-对IOC的理解" class="headerlink" title="34.对IOC的理解"></a>34.对IOC的理解</h1><p>ioc容器：实际上就是map，里面存的是各种对象（在xml里配置的bean、@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的bean节点，根据权限定类名使用反射创建对象放到map里，扫描到打上上述注解的类。</p>
<p>这个时候map里就有各种对象，接下来我们在代码里使用时，通过DI注入（@autowired、@resource）</p>
<p>没有引入IOC容器之前，对象A依赖于对象B，B什么时候创建，需要程序员主动new</p>
<p>引入了IOC容器，当对象A运行到需要对象B时，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<h1 id="35-BeanFactory和ApplicationContext有什么区别？"><a href="#35-BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="35.BeanFactory和ApplicationContext有什么区别？"></a>35.BeanFactory和ApplicationContext有什么区别？</h1><p>ApplicationContext是BeanFactory的子接口</p>
<p>ApplicationContext提供更完整的功能：</p>
<ol>
<li>继承MessageSource，因此支持国际化</li>
<li>统一的资源文件访问方式</li>
<li>提供在监听器中注册bean的事件</li>
<li>同时加载多个配置文件</li>
<li>载入多个上下文，每一个上下文都专注于一个特定的层次</li>
</ol>
<ul>
<li>BeanFactory采用延迟加载形式来注入bean的，即只有在使用getBean（） ，才对该Bean进行实例化</li>
<li>ApplicationContext，它在容器启动时，一次性创建所有的Bean</li>
<li>ApplicationContext占用内存空间</li>
</ul>
<h1 id="36-Spring-Bean的生命周期"><a href="#36-Spring-Bean的生命周期" class="headerlink" title="36.Spring Bean的生命周期"></a>36.Spring Bean的生命周期</h1><ol>
<li>解析类得到BeanDefinition</li>
<li>如果有多个构造方法，则要推断构造方法</li>
<li>确定好构造方法后，进行实例化得到一个对象</li>
<li>对对象中的加@Autowired注解的属性进行属性填充</li>
<li>回调Aware方法，比如BeanNameAware，BeanFactoryAware</li>
<li>调用BeanPostProcessor的初始化前的方法</li>
<li>调用初始化方法</li>
<li>调用BeanPostProcessor的初始化后的方法，在这里会进行AOP</li>
<li>如果当前创建的bean是单例则会放到单例池</li>
<li>使用bean</li>
<li>spring容器关闭时调用DisposableBean中的destory（）方法</li>
</ol>
<p><img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210418000454956.png" alt="image-20210418000454956"></p>
<h1 id="37-解释下Spring支持的几种bean的作用域"><a href="#37-解释下Spring支持的几种bean的作用域" class="headerlink" title="37.解释下Spring支持的几种bean的作用域"></a>37.解释下Spring支持的几种bean的作用域</h1><ul>
<li>singleton：默认，每个容器中只有一个bean的实例，单例的模式有BeanFactory自身来维护。该对象的生命周期和spring IOC容器一致，但在第一次被注入时才会创建。</li>
<li>prototype：为每一个bean请求提供一个实例。在每次注入时都会创建一个新的对象</li>
<li>request：bean被定义为每个HTTP请求中创建一个单例对象，也就是单个请求中都会复用这个单例对象</li>
<li>session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li>
<li>application：bean被定义在ServletContext的生命周期复用一个单例对象</li>
<li>websocket：bean被定义在websocket的生命周期中复用一个单例对象</li>
<li>global-session：全局作用域，现在有得少</li>
</ul>
<h1 id="38-Spring框架中的单例Bean是线程安全的么"><a href="#38-Spring框架中的单例Bean是线程安全的么" class="headerlink" title="38.Spring框架中的单例Bean是线程安全的么"></a>38.Spring框架中的单例Bean是线程安全的么</h1><p>不安全的</p>
<ul>
<li>有状态就是有数据存储功能</li>
<li>无状态就是不会保存数据   controller、service和dao本身并不是线程安全的，只是如果调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</li>
</ul>
<p>不要在bean中声明任何有状态的实例变量或类变量，如果必须，那么就使用ThreadLocal把变量变成线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等这些实现线程同步的方法。</p>
<h1 id="39-Spring框架都用到了哪些设计模式"><a href="#39-Spring框架都用到了哪些设计模式" class="headerlink" title="39.Spring框架都用到了哪些设计模式"></a>39.Spring框架都用到了哪些设计模式</h1><p>简单工程：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p>
<blockquote>
<p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象</p>
</blockquote>
<p>工厂方法：</p>
<blockquote>
</blockquote>
<p>单例模式：确保一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<p>适配器模式：</p>
<p>装饰者模式：</p>
<p>动态代理：</p>
<p>观察者模式：</p>
<p>策略模式： </p>
<h1 id="40-Spring事务的实现方式和原理以及隔离级别"><a href="#40-Spring事务的实现方式和原理以及隔离级别" class="headerlink" title="40.Spring事务的实现方式和原理以及隔离级别"></a>40.Spring事务的实现方式和原理以及隔离级别</h1><p>在使用Spring框架时，可以有两种使用事务的方式，1.编程式；2.申明式。@Transactional就是申明式的。</p>
<p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展。</p>
<p>在方法上加@Transactional注解，就可以开启事务，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，如果这个方法上存在@Transaction注解，那么代理逻辑会先把事务的自动提交设置为false，再去执行原本的业务逻辑，如果执行逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务方法出现了异常，那么则将事务进行回滚。</p>
<p>当然，针对那些异常回滚事务是可以配置的，可以利用@Transaction注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。</p>
<p>Spring事务隔离级别就是数据库的隔离级别：外加一个默认级别</p>
<ul>
<li>read uncommitted(读未提交)</li>
<li>read committed(读已提交) –Oracle默认</li>
<li>repeatable read(可重复读) –MySQL默认</li>
<li>serializable(可串行化)</li>
</ul>
<blockquote>
<p>以Spring配置的为准，如果Spring配置的隔离级别数据库不支持，效果取决于数据库。</p>
</blockquote>
<p>脏读:一个事务读取到另一个事务还未提交的数据.</p>
<p>不可重复读:在一个事务中前后两次,由于其他事务对数据进行修改,读取的结果并不致，导致了不可重复读。</p>
<p>幻读:是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.</p>
<h1 id="41-Spring事务传播机制"><a href="#41-Spring事务传播机制" class="headerlink" title="41.Spring事务传播机制"></a>41.Spring事务传播机制</h1><p>多个事务方法相互调用时。事务如何在这些方法间传播</p>
<p>A方法有事务，B方法有或者无事务，那么在A方法中调用B，A、B事务怎么个回滚呢？</p>
<p>REQUIRED（Spring默认的事务传播类型）：如果当前（调用方）没有事务，则自己（被调用方）新建一个事务，如果当前存在事务，则加入这个事务。</p>
<p>SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</p>
<p>MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</p>
<p>REQUIRED_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。（A的事务与B的事务各自管各自的）</p>
<p>NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务。</p>
<p>NEVER：不使用事务，如果当前事务存在，则抛出异常。</p>
<p>NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）(父事务回滚，子事务一定回滚；子事务回滚，父事务不一定回滚)</p>
<h1 id="42-Spring事务什么时候会失效"><a href="#42-Spring事务什么时候会失效" class="headerlink" title="42.Spring事务什么时候会失效"></a>42.Spring事务什么时候会失效</h1><p>Spring事务的原理AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了！</p>
<ol>
<li><p>发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理类，而是UserService对象本身！</p>
<p> 解决方法很简单，让那个this变成UserService的代理类即可！</p>
</li>
<li><p>方法不是public的</p>
<p> @ Transactional只能用于public方法上，否则事务不会生效；如果要用在非public方法上，可以开启AspectJ代理模式。 </p>
</li>
<li><p>数据库不支持事务。（MySQL使用Myisam引擎）</p>
</li>
<li><p>没有被Spring管理。（方法上加了@Transactional，类没有放到Spring容器）</p>
</li>
<li><p>异常被吃掉，事务不会回滚（或者抛出的异常没有被定义，默认为RuntimeException）</p>
</li>
</ol>
<h1 id="43-什么是bean的自动装配，有哪些方式"><a href="#43-什么是bean的自动装配，有哪些方式" class="headerlink" title="43. 什么是bean的自动装配，有哪些方式"></a>43. 什么是bean的自动装配，有哪些方式</h1><p>开启自动装配，只需要在xml配置文件<bean>中定义“autowire”属性。</bean></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.xxx.Customer&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>autowire属性有五种装配的方法：</p>
<ul>
<li><p>no - 缺省情况下，自动装配是通过“ref”属性手动设定。</p>
<blockquote>
<p>手动装配：以value或ref的方式明确指定属性值都是手动装配。</p>
<p>需要通过“ref”属性来连接bean</p>
</blockquote>
</li>
<li><p>byName - 根据bean的属性名称进行自动装配。</p>
<blockquote>
<p>Customer的属性名称是person,Spring会将bean id为person的bean通过setter方法进行自动装配。</p>
<bean id="customer" class="com.xxx.xxx.Customer" autowire="byName">
</bean></blockquote>
</li>
<li><p>byType</p>
</li>
<li><p>constructor - 构造器注入，类似byType</p>
</li>
<li><p>autodetect - 如果有构造器，按照构造器；没有构造器，按照byType</p>
</li>
</ul>
<p>@Autowired自动装配bean，可以在字段、setter方法，构造函数上使用。</p>
<h1 id="44-SpringBoot、SpringMVC、Spring有什么区别"><a href="#44-SpringBoot、SpringMVC、Spring有什么区别" class="headerlink" title="44.SpringBoot、SpringMVC、Spring有什么区别"></a>44.SpringBoot、SpringMVC、Spring有什么区别</h1><p>Spring是IOC容器，用来管理Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题。</p>
<p>SpringMVC是Spring对web框架的一个解决方案，提供一个总的前端控制器Servlet，用来接收请求，然后定义了一套路由策略（url到handle的映射）及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端。</p>
<p>SpringBoot是Spring提供的一个快速开发工具包，让程序员更方便、快速地开发spring+springMVC应用，简化了配置（约定了默认配置），整合了一系列的解决方法（starter机制）、redis、mongodb、es，可以开箱即用。</p>
<h1 id="45-SpringMVC的工作流程"><a href="#45-SpringMVC的工作流程" class="headerlink" title="45.SpringMVC的工作流程"></a>45.SpringMVC的工作流程</h1><ol>
<li>用户发送请求至前端控制器DispatcherServlet。</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。（url—&gt;handler）</li>
<li>处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器及处理器拦截器（如果有则生成）一并返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。</li>
<li>HandlerAdapter经过适配调用具体的处理器（Controller、也叫后端控制器）</li>
<li>Controller执行后返回ModelAndView。</li>
<li>HandlerAdapter会将ModelAndView返回给DispatcherServlet。</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover试图解析器。</li>
<li>ViewReslover解析后返回具体View。</li>
<li>DispatcherServlet根据View进行渲染试图。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
<h1 id="46-SpringMVC的主要组件"><a href="#46-SpringMVC的主要组件" class="headerlink" title="46.SpringMVC的主要组件"></a>46.SpringMVC的主要组件</h1><p>Handler：也就是处理器。它直接应对这MVC中的C也就是Controller层，它的具体表现形式有很多，可以是类，也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个Handler，只要可以实际处理请求就可以是Handler</p>
<ol>
<li><p>HandlerMapping</p>
<p> 处理器映射器，根据用户请求的资源uri来查找Handler的。在SpringMVC中会有很对请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行，这就是HandlerMapping需要做得事。</p>
</li>
<li><p>HandlerAdapter</p>
<p> 适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就好，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理？这就是HandlerAdapter要做得事情。Handler是用来干活的工具；HandlerMapping用来根据需要干的活找到相应的工具；HandlerAdapter是使用工具干活的人。</p>
</li>
<li><p>HandlerExceptionResolver</p>
<p> 全局异常处理器</p>
</li>
<li><p>ViewResolver</p>
<p> 视图解析器</p>
</li>
<li><p>RequestToViewNameTranslator</p>
</li>
<li><p>LocaleResolver</p>
</li>
<li><p>ThemeResolver</p>
</li>
<li><p>MultipartResolver</p>
<p> 处理文件上传请求</p>
</li>
<li><p>FlashMapManager</p>
</li>
</ol>
<h1 id="47-SpringBoot自动配置原理"><a href="#47-SpringBoot自动配置原理" class="headerlink" title="47.SpringBoot自动配置原理"></a>47.SpringBoot自动配置原理</h1><p><img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210419152211724.png" alt="image-20210419152211724"></p>
<p>@Import+@Configuration+Spring spi</p>
<p>自动配置类由各个starter提供，使用@Configuration+@Bean定义配置类，放到META-INF/spring.factories下</p>
<p>使用Spring spi扫描 META-INF/spring.factories下的配置类</p>
<p>使用@Import导入自动配置类</p>
<h1 id="48-如何理解SpringBoot中的Starter"><a href="#48-如何理解SpringBoot中的Starter" class="headerlink" title="48.如何理解SpringBoot中的Starter"></a>48.如何理解SpringBoot中的Starter</h1><p>使用spring+springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean</p>
<p>starter就是定义一个starter的jar包，写一个@Configuration配置类，将这些bean定义在里面，然后在starter包的META-INF/spring.factories中写入该配置类，SpringBoot按照约定来加载该配置类</p>
<p>开发人员只需要将对应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置）</p>
<h1 id="49-什么是嵌入式服务器？为什么要使用嵌入式服务器"><a href="#49-什么是嵌入式服务器？为什么要使用嵌入式服务器" class="headerlink" title="49.什么是嵌入式服务器？为什么要使用嵌入式服务器"></a>49.什么是嵌入式服务器？为什么要使用嵌入式服务器</h1><p>节省了下载安装tomcat，应用不需要再打war包，然后放到webapp目录下再运行</p>
<p>只需要一个安装了Java的虚拟机，就可以直接在上面部署应用程序了</p>
<p>SpringBoot已经内置了tomcat.jar, 运行main方法时会去启动tomcat，并利用tomcat的spi机制加载springmvc</p>
<h1 id="50-Mybatis的优缺点"><a href="#50-Mybatis的优缺点" class="headerlink" title="50.Mybatis的优缺点"></a>50.Mybatis的优缺点</h1><p>优点：</p>
<ol>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除了sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</li>
<li>与JDBC相比，减少了50%以上的代码，消除了JDBC大量冗余的代码，不需要手动开关连接。</li>
<li>很好地与各种数据库兼容（因为Mybatis使用JDBC来连接数据库，所以只要JDBC支持的数据库Mybatis都支持）</li>
<li>能够与Spring很好地集成。</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射。</li>
</ol>
<p>缺点：</p>
<ol>
<li>SQL语句的编写工作量较大，尤其当字段多，关联表多时，对开发人员编写SQL语句的功底有一定要求。</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ol>
<h1 id="51-Mybatis与Hibernate对比"><a href="#51-Mybatis与Hibernate对比" class="headerlink" title="51.Mybatis与Hibernate对比"></a>51.Mybatis与Hibernate对比</h1><p>SQL和ORM的争论，永远都不会终止。</p>
<p>开发速度对比：</p>
<ul>
<li>Hibernate真正掌握比Mybatis难，Hibernate内部封装了SQL语句，对于简单的增删改查，使用Hibernate能省去写sql，节约大量时间，对于复杂业务，使用Mybatis会好点。</li>
</ul>
<p>开发工作量对比：</p>
<ul>
<li>Hibernate会少点</li>
</ul>
<p>sql优化：</p>
<ul>
<li>Mybatis会占优势</li>
</ul>
<p>对象管理：</p>
<ul>
<li>Hibernate有</li>
</ul>
<p>缓存机制：</p>
<ul>
<li>Hibernate缓存更强大</li>
</ul>
<h1 id="52-和-的区别是什么"><a href="#52-和-的区别是什么" class="headerlink" title="52.#{}和${}的区别是什么"></a>52.#{}和${}的区别是什么</h1><p>#{}是预编译处理、是占位符，${}是字符串拼接。</p>
<p>Mybatis在处理#{}时，会将sql中的#{}替换为？，调用PreparedStatement来赋值；不会有sql注入，提高系统安全性。</p>
<p>Mybatis在处理${}时，会把${}替换成变量的值。会有sql注入问题。</p>
<h1 id="53-简述Mybatis的插件运行原理，如何编写一个插件"><a href="#53-简述Mybatis的插件运行原理，如何编写一个插件" class="headerlink" title="53.简述Mybatis的插件运行原理，如何编写一个插件"></a>53.简述Mybatis的插件运行原理，如何编写一个插件</h1><p>Mybatis只支持ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，</p>
<p>Mybatis使用JDK的动态代理。。。</p>
<h1 id="54-索引的基本原理"><a href="#54-索引的基本原理" class="headerlink" title="54.索引的基本原理"></a>54.索引的基本原理</h1><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理：就是把无序的数据变成有序的查询。</p>
<ol>
<li>把创建了索引地列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h1 id="55-MySql聚簇和非聚簇索引地区别"><a href="#55-MySql聚簇和非聚簇索引地区别" class="headerlink" title="55.MySql聚簇和非聚簇索引地区别"></a>55.MySql聚簇和非聚簇索引地区别</h1><p>都是B+数的数据结构</p>
<ul>
<li>聚簇索引：将数据存储和索引放在一块、并且按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。</li>
<li>非聚簇索引：叶子节点不存储数据、存储的是数据行的地址，也就是说根据索引查找到数据行的位置再去磁盘查找数据。</li>
</ul>
<blockquote>
<p>优势：</p>
<ol>
<li>查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询效率要高；</li>
<li>聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的</li>
<li>聚簇索引适合用在排序的场合，非聚簇索引不适合</li>
</ol>
<p>劣势：</p>
<ol>
<li>。。。</li>
</ol>
</blockquote>
<p>InnoDB中一定有主键，主键一定是聚簇索引，不手动设置，则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏id来当作主键索引</p>
<p>MyISM使用非聚簇索引</p>
<h1 id="56-mysql索引地数据结构，各自优劣"><a href="#56-mysql索引地数据结构，各自优劣" class="headerlink" title="56.mysql索引地数据结构，各自优劣"></a>56.mysql索引地数据结构，各自优劣</h1><p>在Mysql中使用较多的索引有Hash索引，B+数索引，InnoDB存储引擎的默认索引实现为：B+数索引。对于哈希索引来说，底层的数据结构就是哈希表，因此绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<h1 id="57-索引设计的原则"><a href="#57-索引设计的原则" class="headerlink" title="57.索引设计的原则"></a>57.索引设计的原则</h1><p>查询更快、占用空间更小</p>
<ol>
<li>适合索引的列是出现在where字句中的列，或者连接字句中指定的列</li>
<li>基数较小的表，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所有只保持需要的索引有利于查询即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>更新频繁字段不适合创建索引</li>
</ol>
<h1 id="58-MySQL锁的类型有哪些"><a href="#58-MySQL锁的类型有哪些" class="headerlink" title="58.MySQL锁的类型有哪些"></a>58.MySQL锁的类型有哪些</h1><p>基于锁的属性分类：共享锁、排他锁。</p>
<p>基于锁的粒度分类：行级锁（INNODB）、表级锁（INNODB、MYISAM）、页级锁、记录锁、间隙锁、临建锁。</p>
<p>基于锁的状态分类：意向共享锁（读锁）、意向排它锁（写锁）。</p>
<h1 id="59-mysql执行计划怎么看"><a href="#59-mysql执行计划怎么看" class="headerlink" title="59.mysql执行计划怎么看"></a>59.mysql执行计划怎么看</h1><p>执行计划就是sql的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数<img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210420123306590.png" alt="image-20210420123306590"></p>
<ol>
<li><p>id：有几个select就显示几行。id数字越大，执行的优先级越高越先执行。</p>
</li>
<li><p>selectType     表示查询每一select字句的类型</p>
</li>
<li><p>type：优化sql的重要字段</p>
<ul>
<li><p>system：表中只有一行记录，相当于系统表</p>
</li>
<li><p>const：通过索引一次命中，匹配一行数据</p>
</li>
<li><p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配</p>
</li>
<li><p>ref：非唯一性索引扫描，返回匹配某个值的所有</p>
</li>
<li><p>range：只索引给定范围的行，使用一个索引来选择行，一般用于between、&lt;、&gt;</p>
</li>
<li><p>index：只遍历索引树</p>
</li>
<li><p>ALL：全表扫描</p>
</li>
</ul>
</li>
</ol>
<h1 id="60-事务的基本特性和隔离级别"><a href="#60-事务的基本特性和隔离级别" class="headerlink" title="60.事务的基本特性和隔离级别"></a>60.事务的基本特性和隔离级别</h1><p>事务的基本特性ACID：</p>
<p><strong>原子性</strong>指的是一个事务中的操作要么全部成功，要么全部失败。</p>
<p><strong>一致性</strong>指的是数据库总是从一个一致性的状态转换到另一个一致性的状态，但总数是一致的。</p>
<p><strong>隔离性</strong>指的是一个事务的修改在最终提交前，对其他事务是不可见的。</p>
<p><strong>持久性</strong>指的是一旦事务提交，所做的修改就会永远保存到数据库中。</p>
<p>4种隔离级别：</p>
<ul>
<li>read uncommit    读未提交，可能会读到其他事务未提交的数据，也叫脏读。</li>
<li>read commit       读已提交，两次读取结果不一致，会有不可重复读</li>
<li>repeatable read   可重复读，就是每次读取的结果都一样，可能不是数据库中最新的数据，会产生幻读</li>
<li>serializable    串行</li>
</ul>
<h1 id="61-关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#61-关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="61.关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>61.关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h1><p>是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p>
<p>所以优化也是针对这三个方向来的：</p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或纵向的分表。</li>
</ul>
<h1 id="62-ACID靠什么保证的"><a href="#62-ACID靠什么保证的" class="headerlink" title="62.ACID靠什么保证的"></a>62.ACID靠什么保证的</h1><p>A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p>
<p>C一致性由其他三大特性保证、程序代码要保证业务上的一致性</p>
<p>I隔离性有MVCC来保证</p>
<p>D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复</p>
<h1 id="63-什么是MVCC"><a href="#63-什么是MVCC" class="headerlink" title="63.什么是MVCC"></a>63.什么是MVCC</h1><p>多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链</p>
<p>MVCC只在read commited 和 repeatable read 两个隔离级别下工作，其他两个隔离级别和MVCC不兼容，因为read uncommitted 总是读取到最新的数据行，而不是符合当前事务版本的数据行。而serializable 则会对所有读取的行都加锁。</p>
<h1 id="61-mysql主从同步原理"><a href="#61-mysql主从同步原理" class="headerlink" title="61.mysql主从同步原理"></a>61.mysql主从同步原理</h1><p>MySQL主从复制主要有三个线程：master(binlog dump thread)、slave（I/O thread、SQL thread），Master一条线程和Slave中的两条线程。</p>
<ul>
<li><p>主节点binlog，主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</p>
</li>
<li><p>主节点log dump 线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。</p>
<p>  。。。</p>
</li>
</ul>
<h1 id="62-简述MyISAM和InnoDB的区别"><a href="#62-简述MyISAM和InnoDB的区别" class="headerlink" title="62.简述MyISAM和InnoDB的区别"></a>62.简述MyISAM和InnoDB的区别</h1><p><strong>MyISAM</strong>：</p>
<p>不支持事务，但是每次查询都是原子的；</p>
<p>支持表级锁，即每次操作是对整个表加锁；</p>
<p>存储表的总行数快，有一个变量保存行数；</p>
<p>一个MyISAM表有三个文件：索引文件、表结构文件、数据文件；</p>
<p>采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</p>
<p><strong>InnoDB</strong>：</p>
<p>支持ACID的事务，支持事务的四种隔离级别；</p>
<p>支持行锁及外键约束；因此可以支持写并发；</p>
<p>不存储总行数，需要全表扫描；</p>
<p>主键索引采用聚簇索引，最好使用自增索引</p>
<h1 id="63-简述MySQL索引类型及对数据库的性能的影响"><a href="#63-简述MySQL索引类型及对数据库的性能的影响" class="headerlink" title="63.简述MySQL索引类型及对数据库的性能的影响"></a>63.简述MySQL索引类型及对数据库的性能的影响</h1><p>普通索引：允许被索引地数据列包含重复的值。</p>
<p>唯一索引：可以保证数据记录的唯一性。</p>
<p>主键：特殊的唯一索引，使用关键字PRIMARY KEY来创建。</p>
<p>联合索引：索引可以覆盖多个数据列，如像INDEX（columnA, columnB）索引。</p>
<p>全文索引：通过 倒排索引，一般使用es</p>
<p>索引可以极大地提高数据的查询速度。</p>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能。</p>
<p>但是会降低插入、删除、更新表的速度，因此在执行这些写操作时，还要操作索引文件。</p>
<p>索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间、如果要建立聚簇索引，那么需要的空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，那么索引非聚簇索引都会跟着变。</p>
<h1 id="64-RDB和AOF机制"><a href="#64-RDB和AOF机制" class="headerlink" title="64.RDB和AOF机制"></a>64.RDB和AOF机制</h1><p><strong>RDB</strong>：Redis DataBase</p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>整个Redis数据库将只包含一个文件 dump.rdb, 方便持久化。</li>
<li>容灾性好，方便备份。</li>
<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所有是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证redis的高性能。</li>
<li>相对于数据集大时，比AOF的启动效率更高。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ol>
<p><strong>AOF</strong>：Append Only File</p>
<p>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>数据安全，Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。</li>
<li>通过append模式写文件</li>
<li>AOF机制的rewrite模式。定期对AOF文件进行重写，以达到压缩的目的</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>AOF文件比RDB文件大，且恢复速度慢。</li>
<li>数据集大的时候，比RDB启动效率低。</li>
<li>运行效率没有RDB高</li>
</ol>
<h1 id="65-Redis的过期键的删除策略"><a href="#65-Redis的过期键的删除策略" class="headerlink" title="65.Redis的过期键的删除策略"></a>65.Redis的过期键的删除策略</h1><p> Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指定Redis中缓存的key过期了，Redis如何处理。</p>
<ul>
<li>惰性过期：只有当访问一个key时，才会判断该key是否过期，过期则清除。该策略可以最大化地节省cpu，但对内存不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。</li>
</ul>
<p>Redis同时使用这两种策略。</p>
<h1 id="66-Redis线程模型，单线程为什么快？"><a href="#66-Redis线程模型，单线程为什么快？" class="headerlink" title="66. Redis线程模型，单线程为什么快？"></a>66. Redis线程模型，单线程为什么快？</h1><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫作文件事件处理器。这个文件事件处理器，它是单线程的，所有Redis才叫作单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。</p>
<p>单线程快的原因：</p>
<ol>
<li>纯内存操作</li>
<li>核心是基于非阻塞的IO多路复用机制</li>
<li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li>
</ol>
<h1 id="67-缓存雪崩、缓存穿透、缓存击穿"><a href="#67-缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="67.缓存雪崩、缓存穿透、缓存击穿"></a>67.缓存雪崩、缓存穿透、缓存击穿</h1><p><strong>缓存雪崩</strong>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间承受大量请求而崩掉。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>缓存数据的过期时间设置随机，防止同一时间数据过期现象发生。</li>
<li>给每一个缓存数据增加对应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li>
<li>缓存预热</li>
<li>互斥锁</li>
</ul>
<p><strong>缓存穿透</strong>是指缓存和数据库中都没有数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截。</li>
<li> 从缓存取不到的数据，在数据库中也找不到时，这时可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒。这样可以防止攻击者反复用同一id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ul>
<p><strong>缓存击穿</strong>是指缓存中没有但是数据库中有的数据（一般指缓存时间过期），这是由于并发用户特别多，同时大量的请求会压垮数据库。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>设置热点数据永不过期。</li>
<li>加互斥锁</li>
</ul>
<h1 id="68-Redis事务实现"><a href="#68-Redis事务实现" class="headerlink" title="68.Redis事务实现"></a>68.Redis事务实现</h1><ol>
<li><p>事务开始</p>
<p> multi命令，标志命令的执行，标识着一个事务的开始</p>
<p> exec命令，开始执行</p>
<p> discard，放弃执行事务</p>
<p> watch，客观锁</p>
<p> unwatch，接触监控</p>
</li>
</ol>
<h1 id="69-Redis集群方案"><a href="#69-Redis集群方案" class="headerlink" title="69.Redis集群方案"></a>69.Redis集群方案</h1><p>主从</p>
<p><strong>哨兵模式</strong>：</p>
<p>sentinel, 哨兵是redis集群中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控redis master和slave进程是否正常工作。</li>
<li>消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果master node挂断了，会自动转移到slave nide上。</li>
<li>配置中心：如果故障转移发生了，通知client客户端新的master地址。</li>
</ul>
<h1 id="70-CAP理论、BASE理论"><a href="#70-CAP理论、BASE理论" class="headerlink" title="70.CAP理论、BASE理论"></a>70.CAP理论、BASE理论</h1><p>Consistency(一致性)：</p>
<p>即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。</p>
<p>对客户端来说，一致性指的是并发访问时更新过得数据如何获取的问题。</p>
<p>对服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p>
<p>Avaliability(可用性)：</p>
<p>即服务一直可用，而且是正常响应时间。系统能够很好地为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p>
<p>Partition Tolerance(分区容错性)：</p>
<p>即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p>
<p>CP和AP：分区容错是必须保证的，当发生网络分区时，如果要继续服务，那么强一致性和可用性只能2选1</p>
<p>BASE是Basically Avaliable(基本可用)、Soft state(软状态)和Eventually consistent（最终一致性）</p>
<p>基本可用：</p>
<ul>
<li>响应时间上的损失：正常情况下，处理用户请求需要0.5s返回结果，但是由于系统出现故障，处理用户请求的时间变为3s。</li>
<li>系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于吸氧访问量的突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<p>软状态：数据同步允许一定的延迟。</p>
<p>最终一致性：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要求实时。</p>
<h1 id="71-负载均衡算法、类型"><a href="#71-负载均衡算法、类型" class="headerlink" title="71.负载均衡算法、类型"></a>71.负载均衡算法、类型</h1><ol>
<li><p>轮询法</p>
<p> 将请求按顺序轮流地分配到后端机器上</p>
</li>
<li><p>随机法</p>
<p> 通过随机算法，随机分配到后端机器上</p>
</li>
<li><p>源地址哈希法</p>
<p> 根据客户端的IP地址，通过哈希函数计算的到一个数值，用该数值对服务器列表的大小进行取模，得到的结果便是客户端要访问的服务器的序号。</p>
</li>
<li><p>加权轮询法</p>
<p> 给配置高、负载低的机器配置更高的权重，让其处理更多的请求</p>
</li>
<li><p>加权随机</p>
<p> 根据后端服务器的配置，系统的负载不同配置权重随机</p>
</li>
<li><p>最小连接数法</p>
<p> 最小连接数算法比较灵活和智能，由于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中连接数少的。</p>
</li>
</ol>
<p>类型：</p>
<ol>
<li><p>DNS方式实现负载均衡</p>
</li>
<li><p>硬件负载均衡：F5和A10</p>
</li>
<li><p>软件负载均衡：</p>
<p> nginx、HAproxy、LVS</p>
</li>
</ol>
<h1 id="72-分布式架构下，Session共享有什么方案"><a href="#72-分布式架构下，Session共享有什么方案" class="headerlink" title="72.分布式架构下，Session共享有什么方案"></a>72.分布式架构下，Session共享有什么方案</h1><ol>
<li><p>采用无状态服务，抛弃session，使用jwt</p>
</li>
<li><p>存入Cookie（有安全风险）</p>
</li>
<li><p>服务器之间进行session同步，这样可以保证每个服务器上都有全部的Session信息，不过当服务器数量多的时候，会有延迟</p>
</li>
<li><p>IP绑定策略</p>
</li>
<li><p>使用Redis存储（用得多）</p>
<p> 把Session方法Redis中存储，</p>
<ul>
<li>实现Session</li>
<li>可以水平扩展</li>
<li>服务器重启Session不失效</li>
<li>不仅可以跨服务器Session共享，甚至可以跨平台（例如网页端，App端）</li>
</ul>
</li>
</ol>
<h1 id="73-简述RPC、RMI的理解"><a href="#73-简述RPC、RMI的理解" class="headerlink" title="73.简述RPC、RMI的理解"></a>73.简述RPC、RMI的理解</h1><p>RPC：远程过程调用。在本地调用远程的函数，可以跨语言实现，httpClient</p>
<p>RMI：远程方法调用。java中用于实现RPC的一种机制，RPC的java版本，是j2ee的网络调用机制</p>
<h1 id="74-分布式id生成方案"><a href="#74-分布式id生成方案" class="headerlink" title="74.分布式id生成方案"></a>74.分布式id生成方案</h1><ul>
<li><p>uuid</p>
<blockquote>
<ol>
<li>当前日期和时间    时间戳</li>
<li>时钟序列     计数器</li>
<li>全局唯一的IEEE机器识别码，如果有网卡，从网卡 MAC地址获得，没有网卡以其他方式获得。</li>
</ol>
<p>优点：代码简单，性能好，保证唯一（相对而言，重复概率极低）</p>
<p>缺点：</p>
<ul>
<li>每次生成的ID都是无序的，且无法保证趋势递增</li>
<li>是字符串，字符串存储性能差，查询效率慢</li>
<li>UUID长度过长，不适合存储，耗费数据库性能。</li>
<li>ID无业务含义，可读性差</li>
<li>有信息安全问题，有可能泄漏mac地址</li>
</ul>
</blockquote>
</li>
<li><p>数据库自增序列</p>
<blockquote>
<p>单机模式：</p>
<p>优点：</p>
<ul>
<li>实现简单，依靠数据库即可，成本小。</li>
<li>ID数字化，单调自增，满足数据库存储和查询性能。</li>
<li>具有一定的业务可读性</li>
</ul>
<p>缺点：</p>
<ul>
<li>强依赖DB，存在单点问题，如果数据库宕机，则业务不可以。</li>
<li>DB生成ID性能有限，单点数据库压力大，无法抗高并发场景。</li>
<li>信息安全问题，比如暴露订单量，url查询改一下id查到别人的订单。</li>
</ul>
<p>数据库高可用：多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大于节点数</p>
<p>优点：</p>
<ul>
<li>解决了ID生成的单点问题，同时平衡了负载。</li>
</ul>
<p>缺点：</p>
<ul>
<li>系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难</li>
<li>数据库压力大：每次获取一个ID都必须读写一次数据库</li>
<li>主从同步的时候</li>
</ul>
</blockquote>
</li>
<li><p>Leaf—segment</p>
</li>
<li><p>雪花算法（*）</p>
<blockquote>
<p>生成一个64bit的整型数字</p>
<p>第一个符号位0,41位时间戳，10位workId，12位序列化（自增）</p>
<p>位数可以有不同实现</p>
<p>优点：</p>
<ul>
<li>每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳</li>
<li>时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的。</li>
<li>能够根据业务场景数据库节点布置灵活调整bit位划分，灵活度高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>强制依赖机器时钟，如果时钟回拨，会导致重复的ID生成。</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="75-分布式锁解决方案"><a href="#75-分布式锁解决方案" class="headerlink" title="75.分布式锁解决方案"></a>75.分布式锁解决方案</h1><p>需要这个锁独立于每一个服务之外，而不是在服务里面。</p>
<p>数据库：利用主键冲突控制一次只有一个线程能获取锁、非阻塞、不可重入、单点、失效时间。</p>
<p>Zookeeper分布式锁：</p>
<p>Redis分布式锁：setNX，单线程处理网络请求，不需要考虑并发安全性</p>
<p>所有服务节点设置相同的key，返回为0、则锁获取失败</p>
<blockquote>
<p>setNX</p>
<p>问题：</p>
<ol>
<li>早期版本没有超时参数，需要单独设置，存在死锁问题（中途宕机）</li>
<li>后期版本提供加锁与设置时间原子操作，但是存在任务超时，锁自动释放，导致并发问题，加锁与释放锁不是同一线程问题。</li>
</ol>
</blockquote>
<h1 id="76-分布式事务解决方案"><a href="#76-分布式事务解决方案" class="headerlink" title="76.分布式事务解决方案"></a>76.分布式事务解决方案</h1><p>XA规范：分布式事务规范，定义了分布式事务模型</p>
<p>四个角色：事务管理器（协调者TM）、资源管理器（参数者RM）、应用程序AP、通信资源管理器CRM</p>
<p>全部事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚</p>
<p>JTA事务时java对XA规范的实现，对应JDBC的单库事务</p>
<p>两阶段协议</p>
<p><img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210422145203953.png" alt="image-20210422145203953"></p>
<p>第一阶段（prepare）：每一个参与者执行本地事务但不提交，进入ready状态，并通知协调者已经准备就绪。</p>
<p>第二阶段（commit）：当协调者确认每一个参与者都ready后，通知参与者进行commit操作；如果有参与者fail，则发送rollback命令，各参与者做回滚。</p>
<p>问题：</p>
<ul>
<li>单点故障：一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞）</li>
<li>数据不一致：在阶段二，如果事务管理器只发送了部分commit消息，此时网络发生异常，那么只有部分参与者接收。</li>
<li>响应时间较长：参与者和协调者资源都被锁住，提交和回滚之后才能释放。</li>
<li>不确定性：。。</li>
</ul>
<p>三阶段：</p>
<p><img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210422145828167.png" alt="image-20210422145828167"></p>
<h1 id="77-如何实现接口的幂等性"><a href="#77-如何实现接口的幂等性" class="headerlink" title="77.如何实现接口的幂等性"></a>77.如何实现接口的幂等性</h1><ul>
<li>唯一id。每次操作，都根据操作和内容生成唯一的id，在执行之前先判断id是否存在，如果不存在则执行后续操作，并且保存到数据库或redis等。</li>
<li>服务端提供发送token的接口，业务调用接口前先获取token，然后调用业务接口请求时，把token携带过去，服务器判断token是否存在redis中，存在表示第一次请求，可以执行业务，执行业务完成后，最后需要把redis中的token删除。</li>
<li>建去重表。将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了。</li>
<li>版本控制。增加版本号，当版本号符合时，才能更新数据。</li>
<li>状态控制。例如订单有状态已支付、未支付、支付中、支付失败，当处于未支付的时候才允许修改为支付中等。</li>
</ul>
<h1 id="78-简述ZAB协议"><a href="#78-简述ZAB协议" class="headerlink" title="78.简述ZAB协议"></a>78.简述ZAB协议</h1><p>ZAB协议是分布式协调服务Zookeeper专门设计的一种支持崩溃的原子广播协议，实现分布式数据一致性。所有客户端的请求都是写入Leader进程中，然后，由。。。</p>
<p>ZAB协议包括两种基本的模式：<strong>崩溃恢复和消息广播</strong>。</p>
<p><strong>消息广播</strong>：</p>
<p><strong>崩溃恢复</strong>：</p>
<h1 id="79-SpringCloud和Dubbo的区别"><a href="#79-SpringCloud和Dubbo的区别" class="headerlink" title="79.SpringCloud和Dubbo的区别"></a>79.SpringCloud和Dubbo的区别</h1><p>底层协议：springcloud基于http协议，dubbo基于Tcp协议。</p>
<p>注册中心：springcloud使用eureka，dubbo推荐使用zookeeper</p>
<p>模型定义：dubbo将一个接口定义为一个服务，Springcloud则是将一个应用定义为一个服务。</p>
<p>springcloud是一个生态，则Dubbo是springcloud生态中关于服务调用一种解决方案。</p>
<h1 id="80-Linux常用命令"><a href="#80-Linux常用命令" class="headerlink" title="80.Linux常用命令"></a>80.Linux常用命令</h1><ol>
<li><p>常看端口占用情况</p>
<p> netstat  -anp  |grep  端口号</p>
<p> <img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210718134951878.png" alt="image-20210718134951878"></p>
</li>
<li><p>查看当前所有已经使用的端口情况</p>
<p> netstat  -nultp</p>
<p> <img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210718134828297.png" alt="image-20210718134828297"></p>
</li>
<li><p>查看磁盘大小</p>
<p> df -hl</p>
<p> <img src= "/img/girl-female.gif" data-lazy-src="/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/image-20210718135319642.png" alt="image-20210718135319642"></p>
</li>
<li><p>查看日志命令</p>
<p> cat 日志 （加载日志所有信息）</p>
<p> tail -f 日志    （实时查看日志）</p>
<p> cat -n test.log |grep “debug” |more   （这样就分页打印了,通过点击空格键翻页）</p>
<p> cat -n test.log |grep “debug” |less</p>
<p> <strong>cat</strong>命令：用于显示整个文件的内容，单独使用没有翻页功能，经常和 more 命令搭配使用，cat 命令还可以将数个文件合并成一个文件。</p>
<p> <strong>more</strong>命令：让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按 q 键停止显示。 </p>
<p> <strong>less</strong>命令：less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件。所不同的是 less 命令除了可以按空格键向下显示文件外，还可以利用上下键来翻动文件。当要结束浏览时，只要在 less 命令的提示符“：”下按 q 键即可</p>
</li>
<li><p>查看java进程</p>
<p> ps -ef | grep java</p>
</li>
</ol>
<h1 id="81-线上问题分析思路"><a href="#81-线上问题分析思路" class="headerlink" title="81.线上问题分析思路"></a>81.线上问题分析思路</h1><p>遇到线上问题不要慌，首先确认排查问题的思路：</p>
<ol>
<li>查看日志</li>
<li>查看CPU情况</li>
<li>查看TCP情况</li>
<li>查看java线程，jstack</li>
<li>查看java堆，jmap</li>
<li>通过MAT分析堆文件，寻找无法被回收的对象</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">panda17</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://pp12345678.github.io/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/">http://pp12345678.github.io/2021/04/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E9%9B%86%E4%BA%8E%E8%A7%86%E9%A2%91%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E9%87%8E%E5%8F%B2%E3%80%81%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://pp12345678.github.io" target="_blank">不错的网站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/16/h5%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%97%B6%E9%92%9F%E7%89%B9%E6%95%88/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/pp12345678/hexoImg@master/title/other1/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">h5移动的时钟特效</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8BRabbitMQ/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/pp12345678/hexoImg@master/title/other1/13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">消息队列之RabbitMQ</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">1、面向对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81JDK%E3%80%81JRE%E3%80%81JVM%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text">2、JDK、JRE、JVM三者区别和联系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81-%E5%92%8Cequals"><span class="toc-number">3.</span> <span class="toc-text">3、&#x3D;&#x3D;和equals</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-final"><span class="toc-number">4.</span> <span class="toc-text">4.final</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">5.String、StringBuffer、StringBuilder区别及使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">6.重载和重写的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">7. 接口和抽象类的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-list%E5%92%8Cset%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">8.list和set的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-hashCode%E5%92%8Cequals"><span class="toc-number">9.</span> <span class="toc-text">9.hashCode和equals</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">10.ArrayList和LinkedList区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">11. HashMap和HashTable的区别？底层实现是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-ConcurrentHashMap%E5%8E%9F%E7%90%86%EF%BC%8Cjdk7%E5%92%8Cjdk8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">12.ConcurrentHashMap原理，jdk7和jdk8版本的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAIOC%E5%AE%B9%E5%99%A8"><span class="toc-number">13.</span> <span class="toc-text">13.如何实现一个IOC容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">14.什么是字节码？采用字节码的好处是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">15.</span> <span class="toc-text">15.Java类加载器有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">16. 双亲委派模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">17.</span> <span class="toc-text">17.Java中的异常体系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="toc-number">18.</span> <span class="toc-text">18.GC如何判断对象可以被回收</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="toc-number">19.</span> <span class="toc-text">19.线程的生命周期，线程有哪些状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-sleep%EF%BC%88%EF%BC%89%EF%BC%8Cwait%EF%BC%88%EF%BC%89%EF%BC%8Cjoin%EF%BC%88%EF%BC%89%EF%BC%8Cyield%EF%BC%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">20.sleep（），wait（），join（），yield（）的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">21.</span> <span class="toc-text">21.说说你对线程安全的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-Thread%E3%80%81Runable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">22.</span> <span class="toc-text">22.Thread、Runable的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%AF%B9%E6%AF%94%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">23.</span> <span class="toc-text">23.说说你对守护线程（后台线程，对比用户线程）的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">24.</span> <span class="toc-text">24.ThreadLocal的原理和使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">25.</span> <span class="toc-text">25. ThreadLocal内存泄漏的原因，如何避免</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E4%B8%B2%E8%A1%8C"><span class="toc-number">26.</span> <span class="toc-text">26.并发、并行、串行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">27.</span> <span class="toc-text">27.并发的三大特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E8%A7%A3%E9%87%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">28.为什么用线程池？解释线程池参数？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">29.</span> <span class="toc-text">29.简述线程池处理流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%88%E6%B7%BB%E5%8A%A0%E9%98%9F%E5%88%97%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%88%E5%88%9B%E5%BB%BA%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">30.线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">31.</span> <span class="toc-text">31.线程池中线程复用原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-Spring%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">32.</span> <span class="toc-text">32.Spring是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">33.</span> <span class="toc-text">33.对AOP的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">34.</span> <span class="toc-text">34.对IOC的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">35.BeanFactory和ApplicationContext有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">36.</span> <span class="toc-text">36.Spring Bean的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37-%E8%A7%A3%E9%87%8A%E4%B8%8BSpring%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8Dbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">37.</span> <span class="toc-text">37.解释下Spring支持的几种bean的作用域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8BBean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88"><span class="toc-number">38.</span> <span class="toc-text">38.Spring框架中的单例Bean是线程安全的么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-Spring%E6%A1%86%E6%9E%B6%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">39.</span> <span class="toc-text">39.Spring框架都用到了哪些设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">40.</span> <span class="toc-text">40.Spring事务的实现方式和原理以及隔离级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">41.</span> <span class="toc-text">41.Spring事务传播机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-Spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">42.</span> <span class="toc-text">42.Spring事务什么时候会失效</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-%E4%BB%80%E4%B9%88%E6%98%AFbean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="toc-number">43.</span> <span class="toc-text">43. 什么是bean的自动装配，有哪些方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-SpringBoot%E3%80%81SpringMVC%E3%80%81Spring%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">44.</span> <span class="toc-text">44.SpringBoot、SpringMVC、Spring有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-SpringMVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">45.</span> <span class="toc-text">45.SpringMVC的工作流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-SpringMVC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="toc-number">46.</span> <span class="toc-text">46.SpringMVC的主要组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">47.</span> <span class="toc-text">47.SpringBoot自动配置原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringBoot%E4%B8%AD%E7%9A%84Starter"><span class="toc-number">48.</span> <span class="toc-text">48.如何理解SpringBoot中的Starter</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">49.</span> <span class="toc-text">49.什么是嵌入式服务器？为什么要使用嵌入式服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50-Mybatis%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">50.</span> <span class="toc-text">50.Mybatis的优缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51-Mybatis%E4%B8%8EHibernate%E5%AF%B9%E6%AF%94"><span class="toc-number">51.</span> <span class="toc-text">51.Mybatis与Hibernate对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#52-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">52.</span> <span class="toc-text">52.#{}和${}的区别是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-%E7%AE%80%E8%BF%B0Mybatis%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6"><span class="toc-number">53.</span> <span class="toc-text">53.简述Mybatis的插件运行原理，如何编写一个插件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">54.</span> <span class="toc-text">54.索引的基本原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-MySql%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%9C%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">55.</span> <span class="toc-text">55.MySql聚簇和非聚簇索引地区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56-mysql%E7%B4%A2%E5%BC%95%E5%9C%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%90%84%E8%87%AA%E4%BC%98%E5%8A%A3"><span class="toc-number">56.</span> <span class="toc-text">56.mysql索引地数据结构，各自优劣</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">57.</span> <span class="toc-text">57.索引设计的原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-MySQL%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">58.</span> <span class="toc-text">58.MySQL锁的类型有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59-mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E6%80%8E%E4%B9%88%E7%9C%8B"><span class="toc-number">59.</span> <span class="toc-text">59.mysql执行计划怎么看</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#60-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">60.</span> <span class="toc-text">60.事务的基本特性和隔离级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#61-%E5%85%B3%E5%BF%83%E8%BF%87%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%9A%84sql%E8%80%97%E6%97%B6%E5%90%97%EF%BC%9F%E7%BB%9F%E8%AE%A1%E8%BF%87%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E5%AF%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E8%BF%87%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">61.关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#62-ACID%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84"><span class="toc-number">62.</span> <span class="toc-text">62.ACID靠什么保证的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#63-%E4%BB%80%E4%B9%88%E6%98%AFMVCC"><span class="toc-number">63.</span> <span class="toc-text">63.什么是MVCC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#61-mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">64.</span> <span class="toc-text">61.mysql主从同步原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#62-%E7%AE%80%E8%BF%B0MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">65.</span> <span class="toc-text">62.简述MyISAM和InnoDB的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#63-%E7%AE%80%E8%BF%B0MySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">66.</span> <span class="toc-text">63.简述MySQL索引类型及对数据库的性能的影响</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64-RDB%E5%92%8CAOF%E6%9C%BA%E5%88%B6"><span class="toc-number">67.</span> <span class="toc-text">64.RDB和AOF机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#65-Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">68.</span> <span class="toc-text">65.Redis的过期键的删除策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#66-Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">66. Redis线程模型，单线程为什么快？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#67-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">70.</span> <span class="toc-text">67.缓存雪崩、缓存穿透、缓存击穿</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#68-Redis%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">71.</span> <span class="toc-text">68.Redis事务实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#69-Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">72.</span> <span class="toc-text">69.Redis集群方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#70-CAP%E7%90%86%E8%AE%BA%E3%80%81BASE%E7%90%86%E8%AE%BA"><span class="toc-number">73.</span> <span class="toc-text">70.CAP理论、BASE理论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#71-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">74.</span> <span class="toc-text">71.负载均衡算法、类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#72-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8B%EF%BC%8CSession%E5%85%B1%E4%BA%AB%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88"><span class="toc-number">75.</span> <span class="toc-text">72.分布式架构下，Session共享有什么方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#73-%E7%AE%80%E8%BF%B0RPC%E3%80%81RMI%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">76.</span> <span class="toc-text">73.简述RPC、RMI的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#74-%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88"><span class="toc-number">77.</span> <span class="toc-text">74.分布式id生成方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#75-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">78.</span> <span class="toc-text">75.分布式锁解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#76-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">79.</span> <span class="toc-text">76.分布式事务解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#77-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">80.</span> <span class="toc-text">77.如何实现接口的幂等性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#78-%E7%AE%80%E8%BF%B0ZAB%E5%8D%8F%E8%AE%AE"><span class="toc-number">81.</span> <span class="toc-text">78.简述ZAB协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#79-SpringCloud%E5%92%8CDubbo%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">82.</span> <span class="toc-text">79.SpringCloud和Dubbo的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#80-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">83.</span> <span class="toc-text">80.Linux常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#81-%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF"><span class="toc-number">84.</span> <span class="toc-text">81.线上问题分析思路</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By panda17</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">时光终将偷偷地替换掉故事中的主角们</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'vkrCJk396yuTdAx9jL04Ihxb-MdYXbMMI',
      appKey: 'fWQlO67FsfJlS6ORXYbyH0DW',
      placeholder: '我想说点什么',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    }

    if (false) { 
      initData.requiredFields= (''.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://vkrCJk39.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'vkrCJk396yuTdAx9jL04Ihxb-MdYXbMMI',
        "X-LC-Key": 'fWQlO67FsfJlS6ORXYbyH0DW',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="7937580629" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>